<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        
        <title>Ei/Ψ Seminar @ TU/e</title>
        <style>
            nav { margin-right: 2em; padding: 1em; }
            ul { margin: 0; padding-left: 1em; }
            ul.spaced-list > li { margin-bottom: 4ex; }
            ul.spaced-list > li p { margin-bottom: -1ex; }
            a { text-decoration: none; }
            a:hover { text-decoration: underline; }
            h1, h2, h3, h4, h5, h6, b { color: #1a3274; }
            body { color: #4b6e91; margin: 2ex 3ex 2ex 3ex; }
            hr { height: 1px; border: none; background-color: black; }
        </style>
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config;executed=true">
            MathJax.Hub.Config({
                showMathMenu: false,
                tex2jax: {
                    inlineMath: [['$','$']],
                    displayMath: [['\\[','\\]']],
                    processEscapes: true
                },
                displayAlign: "left",
                displayIndent: "2em"
            });
        </script>
        <link rel="icon" href="./favicon.ico">

    <style type="text/css">.backpack.dropzone {
  font-family: 'SF UI Display', 'Segoe UI';
  font-size: 15px;
  text-align: center;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  width: 250px;
  height: 150px;
  font-weight: lighter;
  color: white;
  will-change: right;
  z-index: 2147483647;
  bottom: 20%;
  background: #333;
  position: fixed;
  user-select: none;
  transition: left .5s, right .5s;
  right: 0px; }
  .backpack.dropzone .animation {
    height: 80px;
    width: 250px;
    background: url("chrome-extension://lifbcibllhkdhoafpjfnlhfpfgnpldfl/assets/backpack/dropzone/hoverstate.png") left center; }
  .backpack.dropzone .title::before {
    content: 'Save to'; }
  .backpack.dropzone.closed {
    right: -250px; }
  .backpack.dropzone.hover .animation {
    animation: sxt-play-anim-hover 0.91s steps(21);
    animation-fill-mode: forwards;
    background: url("chrome-extension://lifbcibllhkdhoafpjfnlhfpfgnpldfl/assets/backpack/dropzone/hoverstate.png") left center; }

@keyframes sxt-play-anim-hover {
  from {
    background-position: 0px; }
  to {
    background-position: -5250px; } }
  .backpack.dropzone.saving .title::before {
    content: 'Saving to'; }
  .backpack.dropzone.saving .animation {
    background: url("chrome-extension://lifbcibllhkdhoafpjfnlhfpfgnpldfl/assets/backpack/dropzone/saving_loop.png") left center;
    animation: sxt-play-anim-saving steps(59) 2.46s infinite; }

@keyframes sxt-play-anim-saving {
  100% {
    background-position: -14750px; } }
  .backpack.dropzone.saved .title::before {
    content: 'Saved to'; }
  .backpack.dropzone.saved .animation {
    background: url("chrome-extension://lifbcibllhkdhoafpjfnlhfpfgnpldfl/assets/backpack/dropzone/saved.png") left center;
    animation: sxt-play-anim-saved steps(20) 0.83s forwards; }

@keyframes sxt-play-anim-saved {
  100% {
    background-position: -5000px; } }
</style><style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 2px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 2px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: 1em}
.MathJax_MenuRadioCheck.RTL {right: 1em; left: auto}
.MathJax_MenuLabel {padding: 2px 2em 4px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #CCCCCC; margin: 4px 1px 0px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: Highlight; color: HighlightText}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom > * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd > * {display: block!important}
.MJXp-script-box > *  {display: table!important; height: 50%}
.MJXp-script-box > * > * {display: table-cell!important; vertical-align: top}
.MJXp-script-box > *:last-child > * {vertical-align: bottom}
.MJXp-script-box > * > * > * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over > * {display: block!important}
.MJXp-munderover > * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable > * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
.MathJax_PHTML .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style><style type="text/css">.MathJax_Display {text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%}
.MathJax .merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MathJax .MJX-monospace {font-family: monospace}
.MathJax .MJX-sans-serif {font-family: sans-serif}
#MathJax_Tooltip {background-color: InfoBackground; color: InfoText; border: 1px solid black; box-shadow: 2px 2px 5px #AAAAAA; -webkit-box-shadow: 2px 2px 5px #AAAAAA; -moz-box-shadow: 2px 2px 5px #AAAAAA; -khtml-box-shadow: 2px 2px 5px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true'); padding: 3px 4px; z-index: 401; position: absolute; left: 0; top: 0; width: auto; height: auto; display: none}
.MathJax {display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0}
.MathJax:focus, body :focus .MathJax {display: inline-table}
.MathJax.MathJax_FullWidth {text-align: center; display: table-cell!important; width: 10000em!important}
.MathJax img, .MathJax nobr, .MathJax a {border: 0; padding: 0; margin: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; vertical-align: 0; line-height: normal; text-decoration: none}
img.MathJax_strut {border: 0!important; padding: 0!important; margin: 0!important; vertical-align: 0!important}
.MathJax span {display: inline; position: static; border: 0; padding: 0; margin: 0; vertical-align: 0; line-height: normal; text-decoration: none}
.MathJax nobr {white-space: nowrap!important}
.MathJax img {display: inline!important; float: none!important}
.MathJax * {transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none}
.MathJax_Processing {visibility: hidden; position: fixed; width: 0; height: 0; overflow: hidden}
.MathJax_Processed {display: none!important}
.MathJax_ExBox {display: block!important; overflow: hidden; width: 1px; height: 60ex; min-height: 0; max-height: none}
.MathJax .MathJax_EmBox {display: block!important; overflow: hidden; width: 1px; height: 60em; min-height: 0; max-height: none}
.MathJax_LineBox {display: table!important}
.MathJax_LineBox span {display: table-cell!important; width: 10000em!important; min-width: 0; max-width: none; padding: 0; border: 0; margin: 0}
.MathJax .MathJax_HitBox {cursor: text; background: white; opacity: 0; filter: alpha(opacity=0)}
.MathJax .MathJax_HitBox * {filter: none; opacity: 1; background: transparent}
#MathJax_Tooltip * {filter: none; opacity: 1; background: transparent}
@font-face {font-family: MathJax_Main; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Main-Regular.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Main-Regular.otf?V=2.7.1') format('opentype')}
@font-face {font-family: MathJax_Main-bold; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Main-Bold.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Main-Bold.otf?V=2.7.1') format('opentype')}
@font-face {font-family: MathJax_Main-italic; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Main-Italic.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Main-Italic.otf?V=2.7.1') format('opentype')}
@font-face {font-family: MathJax_Math-italic; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Math-Italic.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Math-Italic.otf?V=2.7.1') format('opentype')}
@font-face {font-family: MathJax_Caligraphic; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Caligraphic-Regular.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Caligraphic-Regular.otf?V=2.7.1') format('opentype')}
@font-face {font-family: MathJax_Size1; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Size1-Regular.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Size1-Regular.otf?V=2.7.1') format('opentype')}
@font-face {font-family: MathJax_Size2; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Size2-Regular.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Size2-Regular.otf?V=2.7.1') format('opentype')}
@font-face {font-family: MathJax_Size3; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Size3-Regular.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Size3-Regular.otf?V=2.7.1') format('opentype')}
@font-face {font-family: MathJax_Size4; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Size4-Regular.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Size4-Regular.otf?V=2.7.1') format('opentype')}
.MathJax .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style></head><script type="text/javascript" id="webrtc-control"></script><body><div style="visibility: hidden; overflow: hidden; position: absolute; top: 0px; height: 1px; width: auto; padding: 0px; border: 0px; margin: 0px; text-align: left; text-indent: 0px; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal;"><div id="MathJax_Hidden"></div></div><div id="MathJax_Message" style="display: none;"></div>
        <h1>Ei/Ψ Seminar</h1>
        <p>
            The Ei/Ψ seminar at Technische Universiteit Eindhoven is currently organized by
            Michele Campobasso and Mairon Mahzoun.
            The seminar is aimed at the crypto and security groups at TU/e.
            If you are interested in presenting your research, please let us know by emailing
            m.campobasso (at) tue.nl and/or m.mahzoun (at) tue.nl.
            We especially encourage presentations of work in progress or open problems
            to stimulate future joint work.
            The talks should be 30 minutes with 15 minutes for questions
            (for open-problem presentations you're welcome to re-allocate your 45 minutes).
            <br>
            <sub><b>Credits</b>: This page was previously maintained by Lorenz Panny and Daan Leermakers, who have been organising the seminars until February 2021. The style is inspired from <a href="https://martindale.info/">Chloe Martindale</a>'s page, who has been co-organising the seminar until autumn 2019.</sub>
        </p>

        <hr style="margin-bottom:-1ex;">

        <h2>Upcoming</h2>
        
        <ul class="spaced-list">
            <li>
                <p>
                    <b>Time &amp; place:</b>
                    4 July 2023 at 12:15 in MF 0.593
                </p><p>
                    <b>Speaker:</b>
                    Gelareh Hasel Mehri (TU/e)
                </p><p>
                    <b>Title:</b>
                    Mitigating Privilege Misuse in Access Control through Anomaly Detection
                </p><p>
                    <b>Abstract:</b>
                    In this work, a framework is proposed to complement access control with anomaly detection for the run-time monitoring of access requests and raising an alert when a user diverges from their normal access behavior.
             </li>
        </ul>

        <hr style="margin-top:1ex;">

        <h2>Past seminars</h2>

        <ul class="spaced-list">
            <li>
                <p>
                    <b>Time &amp; place:</b>
                    21 June 2023 at 12:30 in MF 3.122
                </p><p>
                    <b>Speaker:</b>
                    Marc Vorstermans (TU/e)
                </p><p>
                    <b>Title:</b>
                    Secure Graph Algorithms and Oblivious Data Structures for Multiparty Computation
                </p><p>
                    <b>Abstract:</b>
                    Secure multiparty computation (MPC) is a field in cryptography in which the goal is to develop protocols such that several parties, each with their own private input, can jointly run the protocol without revealing their input. Only information on the input that can be logically deduced from the output may leak. In this thesis, we study graph algorithms and data structures for MPC. A motivating application of graph algorithms is fraud detection in the banking sector. We can convert transaction networks to graphs and perform computations on them, but as we work with privacy-sensitive data it is important to perform these computations securely. By studying three graph theoretical problems, the celebrity problem, cycle detection, and shortest path problem, our goal is to develop various techniques that can be used for graph algorithms for MPC. Next to that, we also take a look at Oblivious RAM (ORAM). ORAM will be used to implement graph algorithms as well as to construct oblivious data structures for MPC. We present an oblivious stack, queue, binary search tree, and priority queue. This is of interest as data structures are closely related to the performance of algorithms.
             </li>
        </ul>
        <ul class="spaced-list">
            <li>
                <p>
                    <b>Time &amp; place:</b>
                    24 May 2023 at 12:30 in MF 0.593
                </p><p>
                    <b>Speaker:</b>
                    Dominik Roy George (TU/e)
                </p><p>
                    <b>Title:</b>
                    Privacy-Preserving Multi-Party Access Control for Third-Party UAV Services
                </p><p>
                    <b>Abstract:</b>
                    Third-Party Unmanned Aerial Vehicle (UAV) Services, a.k.a. Drone-as-a-Service (DaaS), are an increasingly adopted business model, which enables possibly unskilled users, with no background knowledge, to operate drones and run automated drone-based tasks. Although these services provide significant advantages, the resources provided by drones are typically owned by multiple parties. Thus, Third-Party UAV services require adopting multi-party access control solutions. In this context, the leakage of the access control policies specified by the data owners might disclose confidential information and, thus, they should be protected as well. In this talk, we will present a solution that advances an existing privacy-preserving multi-party access control framework based on Secure Function Evaluation to fit the distributed and heterogeneous nature of drone deployments. 
             </li>
        </ul>
        <ul class="spaced-list">
            <li>
                <p>
                    <b>Time &amp; place:</b>
                    20 February 2023 at 12:30 (Zwarte Doos 1.04)
                </p><p>
                    <b>Speaker:</b>
                    Jolijn Cottaar (TU/e)
                </p><p>
                    <b>Title:</b>
                    R.I.P. SIDH
                </p><p>
                    <b>Abstract:</b>
                    Supersingular Isogeny Diffie Hellman (SIDH) was one of the pillars of isogeny-based crypto since its conception in 2011. It made it till the fourth round of the NIST post-quantum competition, a search for new quantum-secure cryptographic systems. In the summer of 2022 however, a series of devastating attacks on SIDH broke the system completely. In this seminar we will talk about SIDH and then give an overview of the attacks that broke this system.
             </li>
            <li>
                <p>
                    <b>Time &amp; place:</b>
                    11 January 2023 at 12:30 (Zwarte Doos 1.03)
                </p><p>
                    <b>Speaker:</b>
                    Antoine Séré (LIX)
                </p><p>
                    <b>Title:</b>
                    Correction proof of Hakyber’s NTT and related developments
                </p><p>
                    <b>Abstract:</b>
                    Kyber is a key-encapsulation mechanism (KEM) that has been selected to be part of NIST’s first post-quantum cryptography standard. It’s security is based on the hardness of a variant of the learning with errors (LWE) problem. Jasmin is a low level programming language designed to implement cryptographic primitives, and correction and security properties of Jasmin programs can be proven using the proof assistant EasyCrypt. A formally verified implementation of Kyber called Hakyber has been developed, written in Jasmin, and formally verified in EasyCrypt. Hakyber’s correction proof involves more complex mathematical structures than the cryptographic primitives that were previously formalized In EasyCrypt. In this talk we will discuss the correction proof of Hakyber, in particular the correction proof of the Number Theoretic Transform (NTT) that Hakyber uses. We will go over the structure of the proof, the difficulties encountered, and the modifications to EasyCrypt that we are currently developing to avoid these issues in future work, namely type classes and annotations.
             </li>
        </ul>
        <ul class="spaced-list">
            <li>
                <p>
                    <b>Time &amp; place:</b>
                    22 November 2022 at 12:30 (Zwarte Doos 1.04)
                </p><p>
                    <b>Speaker:</b>
                    Cristoffer Leite (TU/e)
                </p><p>
                    <b>Title:</b>
                    Actionable Cyber Threat Intelligence for Automated Incident Response
                </p><p>
                    <b>Abstract:</b>
                    Applying Cyber Threat Intelligence (CTI) for active cyber defence, while potentially very beneficial, is currently limited to predominantly manual use. To solve this problem, we propose an automated approach for using CTI during incident response by gathering TTPs available on intelligence reports, mapping them to network incidents, and then using this map to create attack patterns for specific threats. This talk will cover the important steps on this research and the achieved results.
            </li>
        </ul>
        
        <ul class="spaced-list">
            <li>
                <p>
                    <b>Time &amp; place:</b>
                    4 October 2022 at 12:30 (Zwarte Doos 1.03)
                </p><p>
                    <b>Speaker:</b>
                    Silvia Ritsch (ETH Zurich)
                </p><p>
                    <b>Title:</b>
                    Anonymous Communication: Mixnets in the Constructive Cryptography Framework
                </p><p>
                    <b>Abstract:</b>
                    Anonymous Communication has been the subject of study for decades, but its importance has only increased since then. Mixnets are often proposed as a method of creating such an anonymous communication channel from an insecure one such as the internet. In this talk, we will take a look at how to model mixnets based on universal reencryption in the constructive cryptography framework introduced by U. Maurer and R. Renner in 2011 and how to prove their anonymity.
            </li>
        </ul>
        <ul class="spaced-list">
            <li>
                <p>
                    <b>Time &amp; place:</b>
                    4 July 2022 at 12:00 (MF 6.131 and online)
                </p><p>
                    <b>Speaker:</b>
                    Radu Lucian Rădulescu (TU/e)
                </p><p>
                    <b>Title:</b>
                    What underground markets do successful cybercriminals prefer?
                </p><p>
                    <b>Abstract:</b>
                    Some cybercrime marketplaces, which were formerly assumed to be unstable platforms teeming with scammers, have evolved into well-functioning markets that have shown to be a substantial global threat. But which markets are successful and what features make a good market? To answer this question we employ and validate a previously created framework and find what marketplaces cybercriminals prefer.
            </li>
        </ul>
        <ul class="spaced-list">
            <li>
                <p>
                    <b>Time &amp; place:</b>
                    8 March 2022 at 13:00 (online)
                </p><p>
                    <b>Speaker:</b>
                    Matthias Meijers (TU/e)
                </p><p>
                    <b>Title:</b>
                    Formal Verification of Saber
                </p><p>
                    <b>Abstract:</b>
                    This work concerns the formal verification of Saber's public-key encryption scheme in EasyCrypt.
                    Here, "Saber" is one of the finalists in the currently ongoing competition held by NIST with the purpose of standardizing post-quantum cryptography; "EasyCrypt" is a tool specifically designed for the formal verification of cryptographic constructions.
                    The talk will go over the relevant context and motivation for the work, the most important/interesting aspects of the formal verification process (for Saber in EasyCrypt), the obtained results, and some opportunities for potential future work.
            </li>
            <li>
                <p>
                    <b>Time &amp; place:</b>
                    8 February 2022 at 13:00 (online)
                </p><p>
                    <b>Speaker:</b>
                    Boris Škorić (TU/e)
                </p><p>
                    <b>Title:</b>
                    Can't touch this
                </p><p>
                    <b>Abstract:</b>
                    Storing data on an external server with information-theoretic security, while using a key shorter than the data itself, is impossible. As an alternative, we propose a scheme that achieves information-theoretically secure evidence of accessing: The server is able to obtain information about the stored data, but not while staying undetected. Moreover, the client only needs to remember a key whose length is much shorter than the data. We provide a security proof for our scheme, based on an entropic uncertainty relation, similar to QKD proofs. Our scheme works if Alice is able to (reversibly) randomise the message to almost-uniformity with only a short key. By constructing an explicit attack we show that the desired security properties cannot be achieved without this randomisability. 
                </p><p>
                    <b>Link to paper:</b>
                    <a href="https://arxiv.org/abs/2006.02476">arXiv</a>
            </li>
            <li>
                <p>
                    <b>Time &amp; place:</b>
                    15 September 2021 at 13:00 (online)
                </p><p>
                    <b>Speaker:</b>
                    Arne Aarts (TU/e)
                </p><p>
                    <b>Title:</b>
                    Leveraging Partial Model Extractions using Uncertainty Quantification
                </p><p>
                    <b>Abstract:</b>
                    Companies have started to offer paid access to machine learning models as a service (MLaaS). The creation of said models requires the gathering curating and labeling of large amounts of data, which is a costly and time-consuming process. Providing black box access to the model unfortunately leaves one open to cloning attacks. With sufficiently many queries spend to the service it is possible to create a surrogate dataset and extract a clone of the underlying ML model, subverting the business model. We present a new cloning scheme that uses uncertainty quantification (UQ) to get arbitrarily close to the accuracy of the service for any amount of queries spend at the cost of needing to delegate a fraction of inputs to the service. In this two-step scheme the adversary first creates a "partial" clone using a conventional cloning attack with a small number of queries. Next, during inference the adversary uses UQ to decide whether the output of the partial clone is likely in line with that of the service. If not, it will delegate the input to the service and substitute its own output with that of the service. This way an adversary can set up their own competing service leeching from the original. Using this scheme, the overall costs made in terms of queries can be minimized given an expected number of sales such that the adversary can turn a profit. Compared to previous attacks the new scheme allows for significant lower initial costs, ensures an accuracy arbitrarily close to that of the targeted service, and can result in overall lower costs.
            </li>
            <li>
                <p>
                    <b>Time &amp; place:</b>
                    27 May 2021 at 13:00 (online)
                </p><p>
                    <b>Speaker:</b>
                    <a href="https://eleftheriamakri.com/">Eleftheria Makri</a> (KU Leuven)
                </p><p>
                    <b>Title:</b>
                    The return of Eratosthenes: Secure Generation of RSA Moduli using Distributed Sieving
                </p><p>
                    <b>Abstract:</b>
                    Secure multiparty generation of an RSA biprime is a challenging task, which increasingly receives attention, due to the numerous privacy-preserving applications that require it. In this work, we construct a new protocol for the RSA biprime generation task, secure against a malicious adversary, who can corrupt any subset of protocol participants. Our protocol is designed for generic MPC, making it both platform-independent and allowing for weaker security models to be assumed (e.g., honest majority), should the application scenario require it. By carefully ``postponing" the check of possible inconsistencies in the shares provided by malicious adversaries, we achieve noteworthy efficiency improvements. Concretely, we are able to produce additive sharings of the prime candidates, from multiplicative sharings via a semi-honest multiplication, without degrading the overall (active) security of our protocol. This is the core of our sieving technique, increasing the probability of our protocol sampling a biprime. Similarly, we perform the first biprimality test, requiring several repetitions, without checking input share consistency, and perform the more costly consistency check only in case of success of the Jacobi symbol based biprimality test. Moreover, we propose a protocol to convert an additive sharing over a ring, into an additive sharing over the integers. Besides being a necessary sub-protocol for the RSA biprime generation, this conversion protocol is of independent interest. The cost analysis of our protocol demonstrated that our approach improves the current state-of-the-art (Chen et al. -- Crypto 2020), in terms of communication efficiency. Concretely, for the two-party case with malicious security, and primes of 2048 bits, our protocol improves communication by a factor of ~37.
                </p><p>
                    <b>Video link:</b>
                    <a href="https://youtu.be/zleqLSiXXl4">YouTube</a>
            </li>
            <li>
                <p>
                    <b>Time &amp; place:</b>
                    6 April 2021 at 13:00 (online)
                </p><p>
                    <b>Speaker:</b>
                    <a href="https://www.esat.kuleuven.be/cosic/people/raluca-posteuca/">Raluca Posteuca</a> (KU Leuven)
                </p><p>
                    <b>Title:</b>
                    How to backdoor a cipher
                </p><p>
                    <b>Abstract:</b>
                    Newly designed block ciphers are required to show resistance against known attacks, e.g., linear and differential cryptanalysis. Two widely used methods to do this are to employ an automated search tool (e.g., MILP, SAT/SMT, etc.) and/or provide a wide-trail argument. In both cases, the core of the argument consists of bounding the transition probability of the statistical property over an isolated non-linear operation, then multiply it by the number of such operations (e.g., number of active S-boxes).
                    In this talk we show that in the case of linear cryptanalysis such strategies can sometimes lead to a gap between the claimed security and the actual one, and that this gap can be exploited by a malicious designer. We introduce Rood, a block cipher with a carefully crafted backdoor. By using the means of the wide-trail strategy, we argue the resistance of the cipher against linear and differential cryptanalysis. However, the cipher has a key-dependent iterative linear approximation over 12 rounds, holding with probability 1. This property is based on the linear hull effect although any linear trail underlying the linear hull has probability smaller than 1.

            </li>
            <li>
                <p>
                    <b>Time &amp; place:</b>
                    13 October 2020 at 10:00 (online)
                </p><p>
                    <b>Speaker:</b>
                    <a href="https://michelecampobasso.github.io/">Michele Campobasso</a> (TU/e)
                </p><p>
                    <b>Title:</b>
                    Impersonation-as-a-Service: Characterizing the Emerging Criminal Infrastructure for User Impersonation at Scale
                </p><p>
                    <b>Abstract:</b>
                    In this paper we provide evidence of an emerging criminal infrastructure enabling impersonation attacks at scale. Impersonation-as-a-Service (ImpaaS) allows attackers to systematically collect and enforce user profiles (consisting of user credentials, cookies, device and behavioural fingerprints, and other metadata) to circumvent risk-based authentication system and effectively bypass multi-factor authentication mechanisms. We present the ImpaaS model and evaluate its implementation by analysing the operation of a large, invite-only, Russian ImpaaS platform providing user profiles for more than 260'000 Internet users worldwide. Our findings suggest that the ImpaaS model is growing, and provides the mechanisms needed to systematically evade authentication controls across multiple platforms, while providing attackers with a reliable, up-to-date, and semi-automated environment enabling target selection and user impersonation against Internet users as scale.

            </p></li><li>
                <p>
                    <b>Time &amp; place:</b>
                    16 December 2019 at 12:30 (MF 3)
                </p><p>
                    <b>Speaker:</b>
                    Mina Sheikhalishahi (TU/e)
                </p><p>
                    <b>Title:</b>
                    Privacy-preserving Multi-party Access Control
                </p><p>
                    <b>Abstract:</b>
                    Multi-party access control has been proposed to enable collaborative decision making for the protection of co-owned resources. In particular, multi-party access control aims to reconcile conflicts arising from the evaluation of policies authored by different stakeholders for jointly-managed resources, thus determining whether access to those resources should be granted or not. While providing effective solutions for the protection of co-owned resources, existing approaches do not address the protection of policies themselves, whose disclosure can leak sensitive information about, e.g., the relationships of co-owners with other parties. In this paper, we propose a privacy-preserving multi-party access control mechanism, which preserves the confidentiality of user policies. In particular, we propose secure computation protocols for the evaluation of multi-party policies, based on two privacy-preserving techniques, namely homomorphic encryption and secure function evaluation. An experimental evaluation of our approach shows its practical feasibility in terms of both computation and communication costs.

            </p></li><li>
                <p>
                    <b>Time &amp; place:</b>
                    2 December 2019 at 12:30 (MF14)
                </p><p>
                    <b>Speaker:</b>
                    Pavlo Burda (TU/e)
                </p><p>
                    <b>Title:</b>
                    Phishing experiments with humans, or the effectiveness of tailored phishing techniques

                </p><p>
                    <b>Abstract:</b>
                    Organizations worldwide are observing the appearance of more and more sophisticated attacks specifically targeting their employees and customers alike. These attacks exploit tailored information on the victim or organization to increase their credibility. To date, no study has evaluated the role of 'traditional' phishing cognitive effects in these advanced settings. In this paper, we run a phishing controlled experiment targeting 747 subjects employed in two organizations (a university and a large, international consultancy company) to evaluate the interaction between phishing persuasion techniques and success rate in a highly-tailored setting. For this purpose, we borrow from the user notification literature to devise enhanced attack delivery techniques, and evaluate how such techniques affect the success rate of our phishing campaigns. We find that the effect of 'traditional' attack techniques is widely mitigated in highly-tailored phishing settings, suggesting that current user training and detection techniques may be off-target for more sophisticated attacks.
                    However, we find that the means by which the attack is delivered to the victim matter, and can greatly (up to three times) boost the effect of the attack in its base form.

            </p></li><li>
                <p>
                    <b>Time &amp; place:</b>
                    31 October 2019 at 12:30 (MF2)
                </p><p>
                    <b>Speaker:</b>
                    Sowmya Ravidas (TU/e)
                </p><p>
                    <b>Title:</b>
                    On Attribute Retrieval in ABAC
                </p><p>
                    <b>Abstract:</b>
                    Despite the growing interest in Attribute-Based Access Control (ABAC) and the large amount of research devoted to the specification and evaluation of ABAC policies, to date only little work has addressed the issue of attribute management and retrieval. In modern systems, the attributes needed for policy evaluation are often retrieved from external sources (e.g., sensors, access points). This poses concerns on the correctness of policy evaluation as the policy decision point can be provided with incorrect attribute values, which can potentially yield incorrect decisions. In this talk, we present our investigation on the problem of selecting mechanisms for attribute retrieval and its relation with the accuracy of policy evaluation. We first introduce the notion of policy evaluation under error rate and use this notion to compute the evaluation accuracy of a policy. We formulate the Attribute Retrieval Mechanism Selection Problem (ARMSP) in terms of evaluation accuracy and show that ARMSP is exponential in the number of attribute values. To overcome this computation limitation, we investigate approaches to estimate the evaluation accuracy of a policy while maintaining the computation feasible.

            </p></li><li>
                <p>
                    <b>Time &amp; place:</b>
                    21 October 2019 at 12:30 (MF15)
                </p><p>
                    <b>Speaker:</b>
                    Guillaume Dupont (TU/e)
                </p><p>
                    <b>Title:</b>
                    Evaluation Framework for Network Intrusion Detection Systems for In-Vehicle CAN
                </p><p>
                    <b>Abstract:</b>
                    Abstract Modern vehicles are complex safety critical cyber physical systems, that are connected to the outside world, with all security implications it brings. Different network intrusion detection systems (NIDSs) proposed for the CAN bus, the predominant type of in-vehicle network, to improve security are hard to compare due to disparate evaluation methods adopted.
                    In this paper we provide the means to compare CAN NIDSs on equal footing and evaluate the ones detailed in the literature. Based on this we observe some limitation of existing approaches and why in the CAN setting it is intrinsically difficult to distinguish benign from malicious payload. We argue that "meaning-aware" detection (a concept we define) which is challenging (but perhaps not impossible) to create for this setting.

            </p></li><li>
                <p>
                    <b>Time &amp; place:</b>
                    7 October 2019 at 12:30 (MF14)
                </p><p>
                    <b>Speaker:</b>
                    Jana Sotáková (CWI/UvA)
                </p><p>
                    <b>Title:</b>
                    Adventures in Supersingularland
                </p><p>
                    <b>Abstract:</b>
                    The problem of path finding in supersingular isogeny graphs has recently been proposed as a hard problem underlying the post-quantum key exchange scheme SIKE. So far, both quantum and classical attacks have exponential time complexity. However, for a small subset of the vertices, the Spine, path-finding is much easier. For cryptanalysis, the Spine is typically assumed to be randomly distributed through the graph. We will look at many examples of isogeny graphs to show how the Spine sits inside the supersingular isogeny graph.
                    <br>
                    This is joint work with Sarah Arpin, Catalina Camacho-Navarro, Kristin Lauter, Joelle Lim, Kristina Nelson and Travis Scholl.

            </p></li><li>
                <p>
                    <b>Time &amp; place:</b>
                    26 August 2019 at 11:00 (Atlas 4.224)
                </p><p>
                    <b>Speaker:</b>
                    Guillaume Dupont (TU/e)
                </p><p>
                    <b>Title:</b>
                    A Survey of Network Intrusion Detection Systems for Controller Area Network
                </p><p>
                    <b>Abstract:</b>
                    Modern vehicles are complex safety critical cyber physical systems, that are connected to the outside world, with all security implications that brings. To enhance vehicle security several network intrusion detection systems (NIDS) have been proposed for the CAN bus, the predominant type of in-vehicle network. <br>
                    The in-vehicle CAN bus, however, is a challenging place to do intrusion detection as
                    messages provide very little information; interpreting them requires specific knowledge about the implementation that is not readily available. In this paper we collect how existing solutions address this challenge by providing an organized inventory of frame based CAN NIDS proposed in literature, categorizing them based on what information they extract from the network and how they build their model.

            </p></li><li>
                <p>
                    <b>Time &amp; place:</b>
                    8 July 2019 at 12:30 (MF14)
                </p><p>
                    <b>Speaker:</b>
                    Sofía Celi
                </p><p>
                    <b>Title:</b>
                    OTRv4, the newest version of the Off-The-Record protocol
                </p><p>
                    <b>Abstract:</b>
                    OTRv4 is the newest version of the Off-The-Record protocol.
                    As a Privacy Enhancing Technology, it is a protocol where the newest
                    academic research intertwines with real-world implementations. This new
                    version asks us to revisit definitions around deniability
                    (participation, message, online and offline), forward and
                    post-compromise secrecy, and how important they are to the world. In
                    this talk, we will examine the key security properties that secure
                    messaging protocols and applications should have. We will explore how
                    these properties are achieved in OTRv4, in particular, and why they are
                    needed in today’s world.

            </p></li><li>
                <p>
                    <b>Time &amp; place:</b>
                    17 June 2019 at 12:30 (MF15)
                </p><p>
                    <b>Speaker:</b>
                    Chloe Martindale (TU/e)
                </p><p>
                    <b>Title:</b>
                    Are pairings really dead?
                </p><p>
                    <b>Abstract:</b>
                    We will discuss pairings of elliptic curves: a cryptographic primitive used in identity-based encryption and a fundamental building block of privacy protocols. Pairings suffered a blow in 2016 — an improved attack slowing down the favourite constructions in the literature — leading some cryptographers to assume that pairings are dead. <br>
                    We will first give some background on pairings, and then discuss some recent works (not only mine) presenting constructions of pairings for which the lastest attack is ineffective. <br>
                    This talk will refer to joint work with both Chitchanok Chuengsatiansup and Georgios Fotiadis.

            </p></li><li>
                <p>
                    <b>Time &amp; place:</b>
                    27 May 2019 at 12:30 (MF14)
                </p><p>
                    <b>Speaker:</b>
                    Frank van den Bosch-Blom (TU/e)
                </p><p>
                    <b>Title:</b>
                    Efficient Secure Ridge Regression from Randomized Gaussian Elimination
                </p><p>
                    <b>Abstract:</b>
                    We present a practical protocol for secure ridge regression. We develop the necessary secure linear algebra tools, using only basic arithmetic over prime Fields. In particular, we show how to solve linear systems of equations and compute matrix inverses efficiently, using appropriate secure random self-reductions of these problems. The distinguishing feature of our approach is that the use of secure fixed-point arithmetic is avoided entirely, while circumventing the need for rational reconstruction at any stage as well. The effectiveness of our protocol is demonstrated by implementation in a standard setting for information-theoretically secure multiparty computation, tolerating a dishonest minority of passively corrupt parties. Using the MPyC framework, which is based on threshold secret sharing over finite fields, we show how to handle large datasets efficiently, achieving root-mean-square errors arbitrarily close to those of plaintext Scikit-learn. Moreover, we do not assume that any (part) of the datasets is held privately by any of the parties, which makes our protocol much more versatile than previous solutions which utilize assumptions on private held data. Our experiments show that our solution outperforms existing solutions for datasets commonly used for secure ridge regression benchmarking, reaching new heights running efficiently on larger real-world datasets than previous works.

            </p></li><li>
                <p>
                    <b>Time &amp; place:</b>
                    13 May 2019 at 12:30 (MF14)
                </p><p>
                    <b>Speaker:</b>
                    Milan Lopuhaä-Zwakenberg (TU/e)
                </p><p>
                    <b>Title:</b>
                    Measuring privacy and utility of local privacy protocols
                </p><p>
                    <b>Abstract:</b>
                    In a setting where an aggregator is interested in users' private data, but the users do not trust the aggregator, an often used solution is to have the users to mask their private data under random noise. That way the aggregator cannot be certain about any individual's private data, but as the random noise averages out they still obtain information about the user population as a whole. The aggregator and the users have competing requirements for the random noise protocol: the aggregator wants reliable information about population statistics (Utility) while the users want to protect their private data (Privacy). In this talk, we will look at commonly used definitions of Privacy and Security for random protocols, their shortcomings, and how new definitions based on information theory give us a better understanding of the functioning of such random protocols.

            </p></li><li>
                <p>
                    <b>Time &amp; place:</b>
                    29 April 2019 at 12:30 (MF14)
                </p><p>
                    <b>Speaker:</b>
                    Lorenz Panny (TU/e)
                </p><p>
                    <b>Title:</b>
                    Diffie-Hellman reductions
                </p><p>
                    <b>Abstract:</b>
                    Starting from related classical observations, I will present a recent
                    result concerning the security of a post-quantum Diffie-Hellman-style
                    key-exchange protocol in comparison to the corresponding key-recovery
                    problem. <br>
                    For those scared of these words: I will explain what they mean, and
                    I will try to assume no more than some elementary group theory.
                    While these results have no direct practical application, they form a
                    beautiful and accessible example of cryptographic hardness reductions.

            </p></li><li>
                <p>
                    <b>Time &amp; place:</b>
                    3 April 2019 at 12:30 (MF14)
                </p><p>
                    <b>Speaker:</b>
                    Gustavo Banegas (TU/e)
                </p><p>
                    <b>Title:</b>
                    Anything for finding roots
                </p><p>
                    <b>Abstract:</b>
                    Several code-based schemes use a polynomial called "Error locator
                    polynomial" (ELP) where the roots of this polynomial is the error
                    positions that one wants to correct for recovering a noisy codeword that
                    is "<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-1" style="width: 2.707em; display: inline-block;"><span style="display: inline-block; position: relative; width: 2.587em; height: 0px; font-size: 104%;"><span style="position: absolute; clip: rect(1.445em, 1002.53em, 2.467em, -999.997em); top: -2.221em; left: 0em;"><span class="mrow" id="MathJax-Span-2"><span class="mi" id="MathJax-Span-3" style="font-family: MathJax_Math-italic;">m</span><span class="mo" id="MathJax-Span-4" style="font-family: MathJax_Main; padding-left: 0.243em;">+</span><span class="mi" id="MathJax-Span-5" style="font-family: MathJax_Math-italic; padding-left: 0.243em;">e</span></span><span style="display: inline-block; width: 0px; height: 2.227em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.122em; border-left: 0px solid; width: 0px; height: 0.816em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>m</mi><mo>+</mo><mi>e</mi></math></span></span><script type="math/tex" id="MathJax-Element-1">m+e</script>". We are interested in the timing of the operations for
                    evaluate the roots and the leaks that the current methods provide to us
                    for gathering information and later on recover the message. Also, we are
                    interested in how is it possible to fix this problem, what is the impact
                    of a constant-time implementation of it? Is it possible to do it in
                    constant-time?

            </p></li><li>
                <p>
                    <b>Time &amp; place:</b>
                    11 March 2019 at 12:45 (MF07)
                </p><p>
                    <b>Speaker:</b>
                    Filip Davidovich
                </p><p>
                    <b>Title:</b>
                    Security pentesting of the SEC laboratories
                </p><p>
                    <b>Abstract:</b>
                    This report presents the findings of an external and internal security assessment of Technical University of Eindhoven's Malware Laboratory (B-LAB) and Security Operations Center (SOC) infrastructures, conducted in the period between 1st of September 2018 to 1st of February 2019.
                    The security assessment was comprised of two critical parts, where the penetration tester impersonated both an external and an internal attacker. In the effort to assess the general security posture of these infrastructures, the penetration tester has conducted general intelligence gathering, comprehensive network scanning and enumeration, vulnerability assessment and confirmation by means of penetration, as well as pivoting within the infrastructure.
                    The purpose of this engagement was to assess the effectiveness of security measures put in place by Technical University of Eindhoven, further the client, in order to secure confidentiality and integrity of infrastructure's resources, as well as availability of specific systems.

            </p></li><li>
                <p>
                    <b>Time &amp; place:</b>
                    11 March 2019 at 12:00 (MF07)
                </p><p>
                    <b>Speaker:</b>
                    Manos Doulgerakis
                </p><p>
                    <b>Title:</b>
                    Voronoi cells and the closest vector problem
                </p><p>
                    <b>Abstract:</b>
                    In my talk I will first try to give a brief introduction to lattices and mention two main problems we want to solve concerning lattices, the shortest vector problem (SVP) and the closest vector problem (CVP). I will then expand on Voronoi cells and how we can use them to solve the closest vector problem. I will mention what is the Voronoi cell of a lattice, how we can find it and how we can use it in order to solve CVP.
                    Finally I will mention some recent results on the topic.


            </p></li><li>
                <p>
                    <b>Time &amp; place:</b>
                    25 February 2019 at 12:30 (MF15)
                </p><p>
                    <b>Speaker:</b>
                    Jacob Appelbaum (TU/e)
                </p><p>
                    <b>Title:</b>
                    Crypto plumbing: replay attacks and sequence numbers
                </p><p>
                    <b>Abstract:</b>
                    Network protocols have different strategies and threat models for
                    dealing with surveillance, censorship, and with other active tampering.
                    Many of the strategies rest on pre-masssurveillance assumptions that do
                    not hold with the adversaries that we know to be relevant. <br>
                    This talk focuses on a simple concept: sequence numbers and its
                    relation to replay attacks. Preventing replay attacks is usually
                    hand-waved away as a local issue or is ambiguously specified in a way
                    that leaves protocols open to information leakage. <br>
                    We will explore some of the different strategies while comparing and
                    contrasting across myriad of contemporary internet protocols.

            </p></li><li>
                <p>
                    <b>Time &amp; place:</b>
                    11 February 2019 at 12:30 (MF13)
                </p><p>
                    <b>Speaker:</b>
                    Thijs Laarhoven (TU/e)
                </p><p>
                    <b>Title:</b>
                    Lattice-based cryptanalysis

            </p></li><li>
                <p>
                    <b>Time &amp; place:</b>
                    7 January 2019 at 12:45 (MF13)
                </p><p>
                    <b>Speaker:</b>
                    Bram Cappers
                </p><p>
                    <b>Title:</b>
                    Interactive Visualization of Event Logs for Cybersecurity
                </p><p>
                    <b>Abstract:</b>
                    Many domains nowadays try to gain insight in complex phenomena by logging their behavior. Telecom companies for instance analyze their communication networks for the presence of fraud, hospitals analyze patient treatments to discover bottlenecks in the process, and companies study their work flows to improve customer satisfaction. The common ground here is that domains are interested in the analysis of (anomalous) behavior in their system by recording events.  The definition of "anomalous" behavior unfortunately is often ill-defined. In addition, the number of events and data attributes in real-world data is typically in the order of thousands and more. <br>
                    In this presentation we will discuss the role of data visualization for the detection and explanation of anomalous system behavior.  We will show the application of visualization  techniques in the security domain, where we focus on the protection of critical infrastructures against complex virus attacks (a.k.a. Advanced Persistent Threats). The presented techniques however are general enough to be used in other domains.


            </p></li><li>
                <p>
                    <b>Time &amp; place:</b>
                    10 December 2018 at 12:45 (MF15)
                </p><p>
                    <b>Speaker:</b>
                    Laura Genga (TU/e)
                </p><p>
                    <b>Title:</b>
                    Discovering Anomalous Frequent Patterns From Event Logs
                </p><p>
                    <b>Abstract:</b>
                    Organizations usually employ security policies to prevent data breaches and to guarantee the smooth execution of their processes. Traditional security mechanisms adopt a preventive approach, enforcing users to adhere to the prescribed policies. These systems are however too inflexible to be used in flexible processes where users often have to deal with unforeseen situations or emergencies (e.g., Health Care). In this contexts, it is crucial for organizations to assess the compliance of their systems to security policies to detect and react to security infringements. In this talk, I will give a short introduction on compliance checking techniques, discussing how they can be used to mitigate security risks for organization processes. In the end, I'll discuss some recent work we have done to infer patterns of anomalous behaviors from event logs.

            </p></li><li>
                <p>
                    <b>Time &amp; place:</b>
                    26 November 2018 at 12:45 (MF15)
                </p><p>
                    <b>Speaker:</b>
                    Davide Fauri (TU/e)
                </p><p>
                    <b>Title:</b>
                    From Descriptive Data to Actionable Alerts in Network Intrusion Detection Systems
                </p><p>
                    <b>Abstract:</b>
                    Many large-scale systems are not monolythic, but made of many subsystems that exchange messages over a network. To detect when something goes wrong, Network Intrusion Detection Systems (NIDS) usually monitor these messages, infer the state of the monitored system, and eventually raise alerts to the security operators. <br>
                    In this talk, I will give an overview on NIDS, and show two examples taken from my previous research: one of an Industrial Control System and one of a Building Automation System. <br>
                    I will use these examples to explain my view on how the design of a NIDS cannot happen "in a void"; instead, it is influenced by the information that can be extracted from the data sources, and by the information that needs to be conveyed by the alerts. <br>
                    I will conclude presenting a couple of future research directions that I believe can improve the design of NIDS.

            </p></li><li>
                <p>
                    <b>Time &amp; place:</b>
                    12 November 2018 at 12:45 (MF14)
                </p><p>
                    <b>Speaker:</b>
                    Francisco Revson F. Pereira
                </p><p>
                    <b>Title:</b>
                    Quantum Error-Correcting Codes: From the Basics to the Research Trends
                </p><p>
                    <b>Abstract:</b>
                    Quantum error-correcting codes are an essential tool for the practical implementation of quantum computer and quantum communication. In 1996, Robert Calderbank, Peter Shor, and Andrew Steane invented a method to create quantum codes from classical codes, known as the CSS construction. This construction was generalized by Daniel Gottesman with the stabilizer formalism. In this talk, I will give a short introduction of quantum codes, from the definition of errors to the idea of stabilizer formalism. In the end, some current research interests will be shown, ending with some open problems.


            </p></li><li>
                <p>
                    <b>Time &amp; place:</b>
                    29 October 2018 at 12:45 (MF14)
                </p><p>
                    <b>Speaker:</b>
                    Alessandro Amadori (TU/e)
                </p><p>
                    <b>Title:</b>
                    DFA on AES with Byte External Encodings
                </p><p>
                    <b>Abstract:</b> <br>
                    Several White-Box implementations of cryptographic algorithms suffer from side-channel inspired attacks like DFA or DCA. The strength of these attacks is that they can be applied automatically and require minimal reverse engineering effort. In order to mount these attacks, an adversary needs access to the input (DCA) or output (DCA or DFA) of the white-box implementation. Because of this, encoding the input and output of the white-box implementation via external encodings is considered an effective countermeasure against these types of attacks. We want to disprove this belief by presenting an efficient attack that, as DFA and DCA, can be applied in a fully automated way, but at the same time is able to cope with byte external encodings.

            </p></li><li>
                <p>
                    <b>Time &amp; place:</b>
                    15 October 2018 at 12:45 (MF14)
                </p><p>
                    <b>Speaker:</b>
                    Milan Lopuhaä-Zwakenberg (TU/e)
                </p><p>
                    <b>Title:</b>
                    Counting points on algebraic stacks
                </p><p>
                    <b>Abstract:</b>
                    A general problem in mathematics is the following: 'Given a set of axioms, how many objects exist that satisfy those axioms?' In this talk, we look at some categories of mathematical objects, e.g. elliptic curves and their torsion groups, and we show how the language of algebraic stacks (and algebraic geometry in general) can help us count these objects.

            </p></li><li>
                <p>
                    <b>Time &amp; place:</b>
                    1 October 2018 at 12:45 (MF03)
                </p><p>
                    <b>Speaker:</b>
                    Stefan Thaler (TU/e)
                </p><p>
                    <b>Title:</b>
                    Deep Learning in Information Security
                </p><p>
                    <b>Abstract:</b>
                    Machine learning has a long tradition of helping to solve complex information security problems that are difficult to solve manually. Deep Learning(DL) is a sub-field of machine learning, where models are composed of multiple layers of abstraction. In the past few years, there has been an enormous hype about DL, which has also spilled over to information security. <br>
                    In this talk, I want to shed some light on the hype and explore what is behind it (the talk will feature a Gartner hype cycle). First, I will sketch the core principles of DL, its place in the AI landscape and outline some of the compelling properties of DL algorithms. <br>
                    Then, I will give an overview of DL research in information security, which consists of two parts: DL applied to information security problems and security properties of DL algorithms. <br>
                    Finally, I want to highlight some misuses of DL algorithms in information security and want to outline some potential research directions.


            </p></li><li>
                <p>
                    <b>Time &amp; place:</b>
                    4 September 2018 at 11:00 (MF14)
                </p><p>
                    <b>Speaker:</b>
                    Niek J. Bouman (TU/e)
                </p><p>
                    <b>Title:</b>
                    Verified Multi-Precision Arithmetic for Cryptology in C++, at Run-Time and at Compile-Time (<a href="https://martindale.info/eipsi/ctbignum_slides_2018.pdf">slides</a>)
                </p><p>
                    <b>Abstract:</b>
                    Multi-precision arithmetic is arithmetic with operands whose size exceeds the machine word-size, on today's computers typically 64-bits.
                    In this talk, I will talk about the design of a library for multi-precision integer arithmetic for operands in the order of 100–500 bits. Many cryptographic schemes and applications, like elliptic-curve encryption schemes and secure multiparty computation frameworks require multi-precision arithmetic with integers whose bit-lengths lie in that range. <br>
                    The library is written in "optimizing-compiler-friendly" C++, with an emphasis on the use of fixed-size arrays and particular function-argument-passing styles (including the avoidance of naked pointers) to allow the limbs to be allocated on the stack or even in registers. Depending on the particular functionality, we get close to, or significantly beat the performance of existing libraries for multiprecision arithmetic that employ hand-optimized assembly code. <br>
                    Beyond the favorable runtime performance, our library is, to the best of the author's knowledge, the first library that offers big-integer computations during compile-time. For example, when implementing finite-field arithmetic with a fixed modulus, this feature enables the automatic precomputation (at compile time) of the special modulus-dependent constants required for Barrett and Montgomery reduction. Another application is to parse (at compile-time) a base-10-encoded big-integer literal. <br>
                    I will also talk about formal verification of correctness and of the constant-time property of some of the library's functions. I will discuss the "Software Analysis Workbench" (Galois Inc.), an open-source tool for proving equivalence between LLVM bitcode (compiled C of C++ code) and a specification in Cryptol, which is a high-level functional language targeted at describing cryptographic algorithms. Also, I will cover ct-verif (Almeida et al.), a tool for verifying that a particular function is constant-time. The takeaway here is that nowadays there exist mature and easy-to-use open-source tools for fully-automatic formal verification.

        </p></li></ul>

<div style="position: absolute; width: 0px; height: 0px; overflow: hidden; padding: 0px; border: 0px; margin: 0px;"><div id="MathJax_Font_Test" style="position: absolute; visibility: hidden; top: 0px; left: 0px; width: auto; padding: 0px; border: 0px; margin: 0px; white-space: nowrap; text-align: left; text-indent: 0px; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; font-size: 40px; font-weight: normal; font-style: normal; font-family: MathJax_Main, sans-serif;"></div></div></body></html>
